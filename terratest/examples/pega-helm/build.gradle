plugins {
    id 'de.undercouch.download'
    id 'distribution'
}

ext {
    kubernetesProviders = ['kubernetes':'k8s',
                           'openshift':'openshift',
                           'amazon-eks':'eks',
                           'google-kubernetes-engine':'gke',
                           'pivotal-container-service': 'pks',
                           'azure-kubernetes-service': 'aks']
    templateDirectory = "$projectDir/src/main/helm/pega"
    isWindows = org.gradle.internal.os.OperatingSystem.current().isWindows()
    binDirectory = "$buildDir/bin"
    chartDirectory = "$buildDir/chart"
    homeDirectory = "$buildDir/home"
    helmCommand = (isWindows ? ['cmd', '/c', "${binDirectory}/helm.exe"] : ["${binDirectory}/helm"]) + ['--home', homeDirectory]
    publishName = file(templateDirectory).name
    isVersionSemVer = "$version".matches("\\d+\\.\\d+\\.\\d+-.*")
    helmVersion =  isVersionSemVer ? "$version" : "${buildInfoProps.displayVersion}-${version.replaceAll('-','').replaceAll('_','')}"
}

configurations {
    helm
    jfrog
    charts
}

dependencies {
    charts(group: 'com.kubernetes.helm.chart', name: 'cassandra', version: '0.9.4', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'elasticsearch', version: '1.15.1', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'fluentd-elasticsearch', version: '1.5.0', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'kibana', version: '1.1.0', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'traefik', version: '1.68.4', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'metrics-server', version: '2.5.0', ext: 'tgz')
    charts(group: 'com.kubernetes.helm.chart', name: 'aws-alb-ingress-controller', version: '0.1.6', ext: 'tgz')
    jfrog(group: 'jfrog', name: 'jfrog-cli-go', version: '1.22.1', classifier: 'linux-amd64', ext: 'jfrog')
    helm(group: 'github.helm',
          name: 'helm',
          version: '2.12.0',
          classifier: (isWindows ? 'windows-amd64' : 'linux-amd64'),
          ext: (isWindows ? 'zip' : 'tar.gz'))
}

// ensure we clean up generated files that helm creates relative to the chart source.
tasks.clean.doLast {
    file("$templateDirectory/charts").deleteDir()
    file("$templateDirectory/requirements.lock").delete()
}

distributions {
    main {
        baseName = publishName
        contents {
            from ("$templateDirectory") {
                into "/$publishName"
            }
            includeEmptyDirs = false
            exclude "**/*tgz"
        }
    }
}
distTar.enabled = false
jar.enabled = false

task downloadHelm(type: Copy) {
    description 'Download helm to a known local location'

    def helmBinary = configurations.helm.files.last()
    if (isWindows) {
        from zipTree(helmBinary).filter{ it.path.matches(".*helm.*") }
    } else {
        from tarTree(resources.gzip(helmBinary)).filter{ it.path.matches(".*helm.*") }
    }

    into file(binDirectory)

    doLast {
        file("$buildDir/tmp").deleteDir()
    }
}

task downloadDependentCharts(type: Copy) {
    description 'Download our dependent charts into a known location for helm to use'

    from configurations.charts
    into "$templateDirectory/charts"
}

task initializeHelm(dependsOn: [downloadHelm, downloadDependentCharts]) {
    description 'Initialize helm for chart building'
    outputs.dir(homeDirectory)

    doLast {

        exec {
            workingDir projectDir
            commandLine helmCommand + ['init', '--client-only', '--skip-refresh']
        }

        exec {
            workingDir projectDir
            ignoreExitValue = true
            commandLine helmCommand + ['repo', 'remove', 'stable']
        }

        exec {
            workingDir projectDir
            ignoreExitValue = true
            commandLine helmCommand + ['repo', 'remove', 'local']
        }

/*
    TODO: currently Artifactory has a couple show stopper bugs stopping us from using it as
          a proper Chart repo and are listed below. Once these issues have been resolved we
          can un-comment the below code (which will in effect use Artifactory as a proper
          Chart repository) and then remove the dependnecy on the task `downloadDependentCharts`.

            1.) The virtual repos themselves don't have a combined index.yaml file.
            2.) Any helm repo defined still has all the public facing URL's in the given index.yaml file.

        exec {
            workingDir projectDir
            commandLine helmCommand + ['repo', 'add', 'helm-cassandra', "${artifactoryURL}/helm-cassandra", '--username', artifactoryUser, '--password', artifactoryPassword]
        }

        exec {
            workingDir projectDir
            commandLine helmCommand + ['repo', 'add', 'helm-traefik', "${artifactoryURL}/helm-traefik", '--username', artifactoryUser, '--password', artifactoryPassword]
        }

        exec {
            workingDir projectDir
            commandLine helmCommand + ['repo', 'add', 'incubator', "https://kubernetes-charts-incubator.storage.googleapis.com/"]
        }

        exec {
            workingDir projectDir
            commandLine helmCommand + ['repo', 'update']
        }

        exec {
            workingDir templateDirectory
            commandLine helmCommand + ['dependency', 'update']
        }
*/
    }
}

task generateExamples(dependsOn: [initializeHelm]) {
    description 'Generate examples for inclusion into ResourceKit'
    outputs.dir("$buildDir/examples")

    doLast {

      	kubernetesProviders.each { kubeProviderName, kubeProvider ->
            
            def out = isWindows ? "${buildDir}\\examples\\${kubeProviderName}" : "${buildDir}/examples/${kubeProviderName}"
            
            file(out).mkdirs()
            
            exec {
                commandLine helmCommand + ['template', templateDirectory, '--output-dir', out, '--values', "${templateDirectory}/values.yaml", '--namespace', publishName, '--set', "provider=${kubeProvider}", '--set', "actions.execute=deploy"]
            }
            
            copy {
                from "${buildDir}/examples/${kubeProviderName}/${publishName}/templates"
                into "${buildDir}/examples/${kubeProviderName}"
            }
            delete("${out}/${publishName}")
      	}
    }
}

task packageChart(dependsOn: [initializeHelm]) {
    description 'Package this helm chart for publication'
    outputs.file("${chartDirectory}/${publishName}-${helmVersion}.tgz")

    doLast {

        file(chartDirectory).mkdirs()

        // invoke helm to build our chart
        def exitResponse = exec {
            workingDir projectDir
            commandLine helmCommand + ['package', templateDirectory, '-d', chartDirectory, '--save=false', "--version=${helmVersion}"]
        }
    }
}

task downloadJfrog(type: Copy) {
    description 'Download the jfrog cli client so that we can publish a chart to Artifactory'

    from configurations.jfrog.files.last()
    into file(binDirectory)
    rename ~/(.*)jfrog(.*)/, 'jfrog'
    doLast {
        exec {
            workingDir projectDir
            if (isWindows) {
                // nothing yet
            } else {
                commandLine('chmod', '+x', "${binDirectory}/jfrog")
            }
        }
    }
}

task publishChart(dependsOn: [downloadJfrog, packageChart]) {
    description 'Publish the chart to Artifactory'
    onlyIf { !Boolean.valueOf(developerBuild).booleanValue() }

    doLast {
        exec {
            commandLine("${binDirectory}/jfrog",
              'rt',
              'u',
              packageChart.outputs.files.singleFile.path,
              helmRepo,
              "--user=${artifactoryUser}",
              "--password=${artifactoryPassword}",
              "--url=${artifactoryURL}")
        }
    }
}

build.dependsOn packageChart

// TODO: re-enable once Artifactory is upgraded and has all helm related issues ironed out.
//
// artifactoryPublish.finalizedBy publishChart

publishing {
    publications {
      	prpcEngine(MavenPublication) {
            artifact(packageChart.outputs.files.singleFile) {
                builtBy packageChart
                artifactId publishName
                groupId groupdId
            }
        }
    }
}
